<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Mars with Phobos and Deimos (To-Scale Orbits)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #ddd;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      overflow: hidden;
    }
    #info {
      position: fixed;
      left: 0.75rem;
      bottom: 0.75rem;
      font-size: 0.8rem;
      opacity: 0.8;
      max-width: 320px;
      line-height: 1.3;
      pointer-events: none;
    }
    #info code {
      font-size: 0.75rem;
    }
  </style>
</head>
<body>
<div id="info">
  3D Mars + moons.<br>
  Distances & Mars radius share one scale (km → scene units).<br>
  Moon radii exaggerated for visibility.<br>
  <br>
  Coordinate frame:<br>
  – Y axis = rotation axis (north ↑)<br>
  – Equatorial plane = X–Z<br>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';

  // ===== PHYSICAL CONSTANTS (KM, HOURS) =====
  const MARS_RADIUS_KM   = 3396;    // equatorial radius
  const PHOBOS_ORBIT_KM  = 9377;    // semi-major axis (from Mars center)
  const DEIMOS_ORBIT_KM  = 23460;

  const PHOBOS_PERIOD_H  = 7.66;    // orbital period
  const DEIMOS_PERIOD_H  = 30.35;

  // ===== SCENE SETUP =====
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Camera:
  //  - Y axis is "north"
  //  - Camera is placed somewhat above equatorial plane & offset in Z
  const fov = 45;
  const aspect = window.innerWidth / window.innerHeight;
  const near = 0.1;
  const far  = 1000;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

  // We'll position the camera after we know the scale.

  // ===== SCALE: KM → SCENE UNITS =====
  // Make Deimos' orbit ~30 units from center to fit nicely in view.
  const TARGET_DEIMOS_RADIUS_UNITS = 30;
  const KM_TO_UNIT = TARGET_DEIMOS_RADIUS_UNITS / DEIMOS_ORBIT_KM;

  const marsRadius   = MARS_RADIUS_KM  * KM_TO_UNIT;
  const phobosOrbit  = PHOBOS_ORBIT_KM * KM_TO_UNIT;
  const deimosOrbit  = DEIMOS_ORBIT_KM * KM_TO_UNIT;

  // Moon radii: not to scale; bumped up to keep them visible.
  const phobosRadius = marsRadius * 0.07;
  const deimosRadius = marsRadius * 0.05;

  // ===== LIGHTING =====
  // Basic lighting: "sunlight" from one side + ambient fill.
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
  dirLight.position.set(1, 1, 0.5).normalize();
  scene.add(dirLight);

  const ambient = new THREE.AmbientLight(0x404040);
  scene.add(ambient);

  // ===== MARS SPHERE =====
  const marsGeom = new THREE.SphereGeometry(marsRadius, 64, 64);
  const marsMat  = new THREE.MeshPhongMaterial({
    color: 0xcc6633,
    shininess: 12
  });
  const mars = new THREE.Mesh(marsGeom, marsMat);
  scene.add(mars);

  // ===== ROTATION AXIS (NORTH UP) VISUALIZATION =====
  // Y axis is the spin axis; draw a vertical line through Mars.
  const axisLength = marsRadius * 2.0;
  const axisGeom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, -axisLength, 0),
    new THREE.Vector3(0,  axisLength, 0)
  ]);
  const axisMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
  const axisLine = new THREE.Line(axisGeom, axisMat);
  scene.add(axisLine);

  // Simple "N" label above north pole using a tiny sphere + color
  const northMarkerGeom = new THREE.SphereGeometry(marsRadius * 0.05, 16, 16);
  const northMarkerMat  = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const northMarker = new THREE.Mesh(northMarkerGeom, northMarkerMat);
  northMarker.position.set(0, axisLength * 1.05, 0);
  scene.add(northMarker);

  // ===== ORBIT PATHS (EQUATORIAL PLANE = X–Z, Y=0) =====
  function createOrbitCircle(radius, color, segments = 256, opacity = 0.25) {
    const pts = [];
    for (let i = 0; i <= segments; i++) {
      const theta = (i / segments) * Math.PI * 2;
      const x = radius * Math.cos(theta);
      const z = radius * Math.sin(theta);
      pts.push(new THREE.Vector3(x, 0, z));
    }
    const geom = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
      color,
      transparent: true,
      opacity
    });
    return new THREE.LineLoop(geom, mat);
  }

  const phobosOrbitLine = createOrbitCircle(phobosOrbit, 0xffffff, 256, 0.4);
  const deimosOrbitLine = createOrbitCircle(deimosOrbit, 0x888888, 256, 0.25);
  scene.add(phobosOrbitLine);
  scene.add(deimosOrbitLine);

  // ===== MOONS =====
  const phobosGeom = new THREE.SphereGeometry(phobosRadius, 32, 32);
  const phobosMat  = new THREE.MeshPhongMaterial({ color: 0xcccccc });
  const phobos     = new THREE.Mesh(phobosGeom, phobosMat);
  scene.add(phobos);

  const deimosGeom = new THREE.SphereGeometry(deimosRadius, 32, 32);
  const deimosMat  = new THREE.MeshPhongMaterial({ color: 0x999999 });
  const deimos     = new THREE.Mesh(deimosGeom, deimosMat);
  scene.add(deimos);

  // ===== CAMERA POSITION (KEEP NORTH UP) =====
  // Y axis is "north". We keep camera.up = (0,1,0) so north stays vertical on screen.
  camera.up.set(0, 1, 0);

  // Place camera above equatorial plane and back a bit along -Z so we see depth.
  const cameraDistance = DEIMOS_ORBIT_KM * KM_TO_UNIT * 3.0; // ~3× outer orbit radius
  const cameraHeight   = cameraDistance * 0.6;               // adjust elevation

  camera.position.set(0, cameraHeight, cameraDistance);
  camera.lookAt(0, 0, 0);

  // ===== TIME SCALING & ORBITAL SPEEDS =====
  // Keep correct *ratio* of orbital periods, speed up for visualization.
  // Phobos completes one orbit in ~5 seconds of simulation.
  const PHOBOS_PERIOD_SIM_SEC = 5.0;
  const HOURS_PER_SIM_SECOND  = PHOBOS_PERIOD_H / PHOBOS_PERIOD_SIM_SEC;
  const DEIMOS_PERIOD_SIM_SEC = DEIMOS_PERIOD_H / HOURS_PER_SIM_SECOND;

  const PHOBOS_ANG_VEL = (2 * Math.PI) / PHOBOS_PERIOD_SIM_SEC;
  const DEIMOS_ANG_VEL = (2 * Math.PI) / DEIMOS_PERIOD_SIM_SEC;

  let startTime = performance.now();

  // ===== ANIMATION LOOP =====
  function animate(now) {
    requestAnimationFrame(animate);

    const tSec = (now - startTime) / 1000;

    // Angular positions
    const thetaP = PHOBOS_ANG_VEL * tSec;
    const thetaD = DEIMOS_ANG_VEL * tSec;

    // Orbits in equatorial plane X–Z, with Y=0
    phobos.position.set(
      phobosOrbit * Math.cos(thetaP),
      0,
      phobosOrbit * Math.sin(thetaP)
    );

    deimos.position.set(
      deimosOrbit * Math.cos(thetaD),
      0,
      deimosOrbit * Math.sin(thetaD)
    );

    // Optional: slow Mars rotation about its axis (Y).
    mars.rotation.y += 0.002;

    renderer.render(scene, camera);
  }

  animate(performance.now());

  // ===== HANDLE RESIZE =====
  window.addEventListener('resize', () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>
