<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Speed of Light – Solar System to Scale</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    body {
      margin: 0;
      background: #050816;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }
    #spaceCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: pointer;
    }
  </style>
</head>
<body>
<canvas id="spaceCanvas"></canvas>

<script>
  const canvas = document.getElementById('spaceCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // --- Physics / data -------------------------------------------------------

  const AU_KM = 149_597_870;
  const C_KM_S = 299_792;   // speed of light in km/s

  // Rough mean distances from Sun, in AU
  const bodies = [
    { name: "Sun",     distanceAu: 0.00 },
    { name: "Mercury", distanceAu: 0.39 },
    { name: "Venus",   distanceAu: 0.72 },
    { name: "Earth",   distanceAu: 1.00 },
    { name: "Mars",    distanceAu: 1.52 },
    { name: "Jupiter", distanceAu: 5.20 },
    { name: "Saturn",  distanceAu: 9.58 },
    { name: "Uranus",  distanceAu: 19.2 },
    { name: "Neptune", distanceAu: 30.1 },
    { name: "Pluto",   distanceAu: 39.5 },
  ];

  const maxDistanceAu = bodies[bodies.length - 1].distanceAu;
  const maxDistanceKm = maxDistanceAu * AU_KM;
  const maxTravelTimeSec = maxDistanceKm / C_KM_S; // sun->Pluto at light speed

  // --- Simulation speed / mode ---------------------------------------------

  const REAL_TIME_SPEED = 1;   // 1 real second = 1 simulated second
  const FAST_SPEED      = 60;  // 1 real second = 60 simulated seconds (1 min)

  let simMode  = "simulated";  // "simulated" | "real"
  let simSpeed = FAST_SPEED;

  let simTimeSec = 0;
  let lastTimestamp = null;

  // --- UI control hitboxes (bottom panel) -----------------------------------

  const controlsState = {
    modeButton: { x: 0, y: 0, w: 0, h: 0 },
    restartButton: { x: 0, y: 0, w: 0, h: 0 },
    bottomTop: 0,
    bottomHeight: 0,
  };

  // --- helpers --------------------------------------------------------------

  function formatTime(seconds) {
    const s = Math.floor(seconds);
    const h = Math.floor(s / 3600);
    const m = Math.floor((s % 3600) / 60);
    const sec = s % 60;

    if (h > 0) {
      return `${h}h ${m}m ${sec}s`;
    } else if (m > 0) {
      return `${m}m ${sec}s`;
    } else {
      return `${sec}s`;
    }
  }

  function lightTimeSeconds(distanceAu) {
    const km = distanceAu * AU_KM;
    return km / C_KM_S;
  }

  function findCurrentSegment(distanceAu) {
    // Returns {a, b, t} where a,b are bodies, and t is fraction [0,1] between them
    for (let i = 0; i < bodies.length - 1; i++) {
      const a = bodies[i];
      const b = bodies[i + 1];
      if (distanceAu >= a.distanceAu && distanceAu <= b.distanceAu) {
        const span = b.distanceAu - a.distanceAu || 1;
        const t = (distanceAu - a.distanceAu) / span;
        return { a, b, t };
      }
    }
    // Beyond Pluto (loop)
    return {
      a: bodies[bodies.length - 2],
      b: bodies[bodies.length - 1],
      t: 1
    };
  }

  // --- drawing primitives ---------------------------------------------------

  function drawPlanet(ctx, x, y, label, isSun = false, isEarth = false) {
    const radius = isSun ? 10 : isEarth ? 6 : 4;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = isSun ? "#ffcc33" : isEarth ? "#66aaff" : "#aaa";
    ctx.fill();

    ctx.fillStyle = "#eee";
    ctx.font = "12px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(label, x, y + radius + 4);
  }

  function drawPhoton(ctx, x, y) {
    const r = 5;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 12;
    ctx.fillStyle = "#00ffff";
    ctx.fill();
    ctx.shadowBlur = 0; // reset
  }

  // --- layer rendering ------------------------------------------------------

  function drawTopLayer(width, top, height, photonDistanceAu) {
    const marginX = 60;
    const y = top + height * 0.5;
    const lineStartX = marginX;
    const lineEndX = width - marginX;
    const spanX = lineEndX - lineStartX;

    // background
    ctx.fillStyle = "#050816";
    ctx.fillRect(0, top, width, height);

    // Title
    ctx.fillStyle = "#ddd";
    ctx.font = "14px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("Top: Sun → Pluto (distances to scale, light-speed photon)", 16, top + 8);

    // main line
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(lineStartX, y);
    ctx.lineTo(lineEndX, y);
    ctx.stroke();

    // planets
    for (const b of bodies) {
      const frac = b.distanceAu / maxDistanceAu;
      const x = lineStartX + frac * spanX;
      const isSun = b.name === "Sun";
      const isEarth = b.name === "Earth";
      drawPlanet(ctx, x, y, b.name, isSun, isEarth);
    }

    // photon
    const clamped = Math.min(photonDistanceAu, maxDistanceAu);
    const photonFrac = clamped / maxDistanceAu;
    const photonX = lineStartX + photonFrac * spanX;
    drawPhoton(ctx, photonX, y);

    // time / distance text
    ctx.fillStyle = "#ccc";
    ctx.font = "12px system-ui";
    ctx.textAlign = "right";
    ctx.textBaseline = "top";

    ctx.fillText(
      `Sim time since leaving Sun: ${formatTime(simTimeSec)}`,
      width - 16,
      top + 8
    );
    ctx.fillText(
      `Photon distance: ${photonDistanceAu.toFixed(2)} AU`,
      width - 16,
      top + 26
    );
    ctx.fillText(
      `Total Sun→Pluto light time: ${formatTime(maxTravelTimeSec)}`,
      width - 16,
      top + 44
    );
  }

  function drawMiddleLayer(width, top, height, photonDistanceAu) {
    const marginX = 60;
    const y = top + height * 0.5;
    const lineStartX = marginX;
    const lineEndX = width - marginX;
    const spanX = lineEndX - lineStartX;

    ctx.fillStyle = "#030311";
    ctx.fillRect(0, top, width, height);

    ctx.fillStyle = "#ddd";
    ctx.font = "14px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("Middle: Zoomed current hop (Sun→Mercury, Mercury→Venus, ...)", 16, top + 8);

    const { a, b, t } = findCurrentSegment(photonDistanceAu);

    // segment line
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(lineStartX, y);
    ctx.lineTo(lineEndX, y);
    ctx.stroke();

    // Draw just endpoints
    const leftX = lineStartX;
    const rightX = lineEndX;

    const isSunA = a.name === "Sun";
    const isEarthA = a.name === "Earth";
    const isSunB = b.name === "Sun";
    const isEarthB = b.name === "Earth";

    drawPlanet(ctx, leftX, y, a.name, isSunA, isEarthA);
    drawPlanet(ctx, rightX, y, b.name, isSunB, isEarthB);

    // photon within segment
    const photonX = leftX + t * spanX;
    drawPhoton(ctx, photonX, y);

    // info text
    const segDistanceAu = b.distanceAu - a.distanceAu;
    const segTimeSec = lightTimeSeconds(segDistanceAu);

    ctx.fillStyle = "#ccc";
    ctx.font = "12px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    ctx.fillText(
      `Current hop: ${a.name} → ${b.name} (${segDistanceAu.toFixed(2)} AU)`,
      16,
      top + 28
    );
    ctx.fillText(
      `Light time for this hop: ${formatTime(segTimeSec)}`,
      16,
      top + 46
    );
    ctx.fillText(
      `Progress in this hop: ${(t * 100).toFixed(1)}%`,
      16,
      top + 64
    );
  }

  function drawBottomLayer(width, top, height) {
    controlsState.bottomTop = top;
    controlsState.bottomHeight = height;

    ctx.fillStyle = "#040b18";
    ctx.fillRect(0, top, width, height);

    ctx.fillStyle = "#ddd";
    ctx.font = "14px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("Bottom: Controls", 16, top + 8);

    // Panel box
    const panelX = 16;
    const panelY = top + 32;
    const panelW = width - 32;
    const panelH = height - 48;

    ctx.fillStyle = "#0b1222";
    ctx.fillRect(panelX, panelY, panelW, panelH);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.strokeRect(panelX, panelY, panelW, panelH);

    // Buttons
    const buttonHeight = 34;
    const buttonSpacing = 16;
    const buttonWidth = 200;

    const modeBtnX = panelX + 24;
    const modeBtnY = panelY + 24;

    const restartBtnX = panelX + 24;
    const restartBtnY = modeBtnY + buttonHeight + buttonSpacing;

    // store hitboxes
    controlsState.modeButton.x = modeBtnX;
    controlsState.modeButton.y = modeBtnY;
    controlsState.modeButton.w = buttonWidth;
    controlsState.modeButton.h = buttonHeight;

    controlsState.restartButton.x = restartBtnX;
    controlsState.restartButton.y = restartBtnY;
    controlsState.restartButton.w = buttonWidth;
    controlsState.restartButton.h = buttonHeight;

    // Mode button
    ctx.fillStyle = "#151b33";
    ctx.fillRect(modeBtnX, modeBtnY, buttonWidth, buttonHeight);
    ctx.strokeStyle = "#4a5cff";
    ctx.lineWidth = 1.5;
    ctx.strokeRect(modeBtnX, modeBtnY, buttonWidth, buttonHeight);

    ctx.fillStyle = "#eee";
    ctx.font = "13px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const modeLabel = simMode === "simulated"
      ? "Mode: Simulated (×60)"
      : "Mode: Real Time (×1)";
    ctx.fillText(modeLabel, modeBtnX + buttonWidth / 2, modeBtnY + buttonHeight / 2);

    // Restart button
    ctx.fillStyle = "#151b33";
    ctx.fillRect(restartBtnX, restartBtnY, buttonWidth, buttonHeight);
    ctx.strokeStyle = "#ff6666";
    ctx.lineWidth = 1.5;
    ctx.strokeRect(restartBtnX, restartBtnY, buttonWidth, buttonHeight);

    ctx.fillStyle = "#eee";
    ctx.font = "13px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Restart simulation", restartBtnX + buttonWidth / 2, restartBtnY + buttonHeight / 2);

    // Info text on the right
    ctx.fillStyle = "#ccc";
    ctx.font = "12px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    const infoX = panelX + 24 + buttonWidth + 40;
    const infoY = panelY + 24;

    ctx.fillText(
      "Toggle between real time (×1) and accelerated (×60) simulation.",
      infoX,
      infoY
    );
    ctx.fillText(
      "Restart sends the photon back to the Sun (t = 0).",
      infoX,
      infoY + 20
    );
  }

  // --- shared handler for click/touch on canvas controls --------------------

  function handleCanvasInteraction(x, y) {
    const { modeButton, restartButton } = controlsState;

    function inButton(btn) {
      return (
        x >= btn.x && x <= btn.x + btn.w &&
        y >= btn.y && y <= btn.y + btn.h
      );
    }

    if (inButton(modeButton)) {
      // toggle mode
      if (simMode === "simulated") {
        simMode = "real";
        simSpeed = REAL_TIME_SPEED;
      } else {
        simMode = "simulated";
        simSpeed = FAST_SPEED;
      }
      return;
    }

    if (inButton(restartButton)) {
      simTimeSec = 0;
      return;
    }
  }

  canvas.addEventListener("click", (event) => {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    handleCanvasInteraction(x, y);
  });

  // touch support for iPhone / iPad
  function handleTouch(event) {
    event.preventDefault(); // avoid double-tap zoom / scrolling
    const touch = event.touches[0];
    if (!touch) return;

    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    handleCanvasInteraction(x, y);
  }

  canvas.addEventListener("touchstart", handleTouch, { passive: false });

  // --- main loop ------------------------------------------------------------

  function loop(timestamp) {
    if (lastTimestamp == null) lastTimestamp = timestamp;
    const dtReal = (timestamp - lastTimestamp) / 1000; // seconds
    lastTimestamp = timestamp;

    simTimeSec += dtReal * simSpeed;

    // Loop when photon passes Pluto
    if (simTimeSec > maxTravelTimeSec) {
      simTimeSec = 0;
    }

    const photonDistanceKm = C_KM_S * simTimeSec;
    const photonDistanceAu = photonDistanceKm / AU_KM;

    const w = canvas.width;
    const h = canvas.height;
    const layerHeight = h / 3;

    ctx.clearRect(0, 0, w, h);

    drawTopLayer(w, 0 * layerHeight, layerHeight, photonDistanceAu);
    drawMiddleLayer(w, 1 * layerHeight, layerHeight, photonDistanceAu);
    drawBottomLayer(w, 2 * layerHeight, layerHeight);

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
</script>
</body>
</html>
